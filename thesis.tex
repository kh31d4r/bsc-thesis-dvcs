\documentclass{article}

\title{Distributed Version Control Systems}

%\author{
% \IEEEauthorblockN{Daniel Persson}
% \IEEEauthorblockA{daniel@silvertejp.org} \and
%
% \IEEEauthorblockN{Olof Johansson}
% \IEEEauthorblockA{olof@ethup.se}
%}
%
%\IEEEpubid{0000--0000/00\$00~\copyright~2011}
%
\begin{document}

\maketitle

\begin{abstract}
 Place abstract here.
\end{abstract}

%\begin{IEEEkeywords}
% Version Control, Configuration Management
%\end{IEEEkeywords}

\section{Introduction}

%\section{Background}
%
%\subsection{The History of Version Control}
%The history of Version Control Systems can be divided into three
%categories; the ones that only manages local files, the ones that rely
%on a central server to serve connecting clients, and finally the
%distributed ones, where every 'node' can act as both a client and a
%server. The three categories roughly follow each other
%chronologically, naturally with transition-periods in between. At the
%moment the dominating tools are mostly client-server, but the
%distributed ones are rising fast in popularity, so perhaps we are
%currently in the start of a new transition.
%
%\subsubsection{The Local Era}
%The first VCS ever released was the \emph{Source Code Control System}
%(SCCS) in 1972. SCCS tried to solve a number of problems that software
%developers of that time had. Manually managing several versions of the
%same product simultaneously was not feasible in the long run for
%several reasons described by the creator of SCCS, Marc J. Rochkind
%\cite{sccs}:
%
%\begin{itemize}
% \item The amount of space to store the source code may be several
%       times that needed for any particular version.
% \item Fixes made to one version sometimes fail to get made to
%       other versions.
% \item When changes occur it is difficult to tell exactly what changed
%       and when.
% \item When a customer has a problem it is hard to figure out what
%       version he has.
%\end{itemize}
%
%Instead of saving entire files in various states, SCCS stores the
%differences between versions of the same file (called diffs, or
%deltas). With each delta SCCS also stores metadata such as who made
%the change, why, and when. This did not only save precious storage
%space, but also provided the \emph{traceability} that the software
%developers had previously lacked.
%
%It is worth noting that SCCS was not the only VCS that followed the
%philosophy of storing the files locally, \emph{Revision Control
%  System} (RCS) was released in 1982 and gradually took over as the
%dominant VCS for Unix.
%

\subsection{VCS Workflow}

VCS can be used in a number of ways. Some limits are posed by the choice
of tools. Subversion is built for centralized version control, whereas
tools like git or mercurial are built for decentralized. Members of the 
latter category are generally more flexible; e.g. git is almost as simple 
to run centralized as running it decentralized as it is intended. The 
Telia Smart Home project has chosen to use git. The reasons for this are
several: the ability to use git decentralized as well a centralized was a
major point. Also, the prior experience from some members of the project
made the transition for other members less burdensome.

But defining a workflow does not end with selecting a tool. As stated, 
git is very flexible in the way developers interact with it. It is not
uncommon to use it centralized, and in fact, the Telia Smart Home project
does just this in their documentation repository. But one of the key 
strength is its decentralization. It has no enforced "central repository"
through which all changesets must pass. If the team want to have a 
centralized repository it must itself give a arbitrary repository that
semantic meaning.

The workflow designed used for the code repositories in the Telia Smart 
Home project is based upon individual developer repositories and branches.
Each developer has an own repository, and makes commits to this. It then
pushes changes to a repository on a central build server. Here, a build
is triggered using Jenkins continuous integration system and the commit is
also forwarded to the so called "baseline" repository, but to a developer's
private branch.

The release manager is now notified that there is a commit awaiting
approval. He or she can check build and test status on Jenkins and see the
delta between baseline and the proposed patch. After possibly running local
tests, the release manager can either approve and merge the commit or
reject it and inform the author of why it wasn't suitable for inclusion.
If the commit is merged, other developers are now able to merge it into
their local repositories, their working copy of the source code.

When designing this system, the sought benefits was the integrated code 
review and approval system. With this, the release managers could validate 
adherence to coding conventions as well as making sure that the system
is buildable and all unit tests passes. Possibly, much of this could even
have been automated (e.g. static code analysis and coding style validation
tools are commonplace) to an even higher degree, but that is, as always, a 
cost/benefit question.

Are there any alternatives to this? Certainly. As stated twice before, git
is indeed quite flexible. It will yield to the wishes of the user. The 
workflow described above is in fact not common, but invented ad hoc for
this project. We were unable to find any references to a workflow similar
to this in the literature. Some more common alternative workflows to use
with git:

\begin{itemize}
 \item \textbf{Centralized}: 
	Using git in a way similar to e.g. Subversion or other more traditional
	tools still give the user some advantages. The process of branching and
	merging is many times more well developed in git than it is in tools like
	Subversion. A property of the distributed nature of git gives yet another
	benefit: having all of the history available locally. You don't need
	network to be able to see what changes was introduced to a particular
	commit, and indeed no network to be able to see the commit log.

 \item \textbf{Topic branches}: 
  Working on a new cool, but experimental feature? Perhaps it is not as 
  tested as the rest of the system is. You probably don't want to have 
  it in the main code. Create a branch specifically for this "topic" or
  "feature".

 \item \textbf{Benevolent dictator}: 
  A workflow, especially popular within open source projects, is the
  benevolent dictator workflow. There is one designated maintainer, and
  other contributers make "pull requests", primarily via e-mail.  If the
  benevolent dictator accepts the patch, he or she merges it into his or
  hers own repository, where everybody gets their source code from. The
  name, "Benevolent dictator", is a term jokingly used about Linus
  Torvalds, the initial author and later primary maintainer for the Linux
  kernel (and also, the initial author of git!).
\end{itemize}

Each of these workflow are appropriate in some situations. None of these
totally fitted the needs of the Telia project though.

\section{Research Methodology}

\subsection{Research Questions}
Given the description in the background we intend to investigate the
benefits and drawbacks of using that workflow. To tackle these issues
we have identified the following research questions:

\begin{itemize}
 \item How do the developers adapt to the workflow described above?
 \item How does the workflow affect code quality in relation to the
       release management and code review?
\end{itemize}

By code quality we mean both adherence to the Coding Convention and
error frequency, specifically build and automatic unit-test errors.

\subsection{Research Methodology}
To answer the questions we will conduct both a review of literature in
the field of configuration management in general, and version control
systems in particular, and then conduct a post-mortem analysis of the
project. The primary means of doing the post-mortem analysis will be
to conduct interviews with participants in their various roles. In
addition to this we will also collect data from various project
management and configuration management tools and systems.

\subsubsection{Literature Review}


\subsubsection{Post-mortem Analysis}
The post-mortem analysis will primarily be based on interviews with
participants in the Telia Smart Home project and questionnaries with
members from other projects within the same course framework. We will
base the interviews and questionnaries around these questions:

\begin{itemize}
 \item How would you rate your previous experience in using Version Control 
       Systems?
 \item How would you rate your proficiency in using Version Control Systems?
 \item What benefits do you see in using this workflow?
 \item What drawbacks do you see in using this workflow?
 \item Do you have any suggestions for improvements?
 \item What is your overall opinion of the workflow?
\end{itemize}

The post-mortem analysis will also include an analysis of various data
collected during the project. Most of this data will come from
different configuration and project management tools, such as Git for
Version Control, Jenkins for continuous integration and Redmine for
time management and issue tracking.

From Git we will extract metadata related to each commit, such as
time, size, author and commit messages, Jenkins can produce data on
build and test errors, and from Redmine we will compile reports
related to time spent on release management.

The data collected from the project and configuration management tools
will then be correlated with the data gained from the interviews and
questionnaries.

\bibliographystyle{plain} 
\bibliography{references}

\end{document}
